\chapter{Preámbulo}
\section{Introducción a la computación cuántica}
% Introducir suavemente el tema de la computación cuántica. Como surge, por que, 
% y para que sirve

\subsection{Mecánica cuántica}
La naturaleza se comporta de una forma sorprendentemente inesperada a medida que 
la escala a la que se observan los detalles se hace cada vez más pequeña.  
Resulta muy extraño describir dicho comportamiento en comparación con las cosas 
que estamos acostumbrados a ver en el día a día. Sin embargo, existe una serie 
de reglas que se han ido descubriendo, y que siempre se cumplen (hasta ahora lo 
han hecho). Además estas reglas son excepcionalmente simples, y pueden ser 
descritas mediante las fórmulas matemáticas que hasta ahora conocemos. Este 
conjunto de reglas se conocen como los postulados de la mecánica cuántica.

Una de las ventajas de poder describir el comportamiento de algún suceso, es la 
posibilidad de emplearlo de forma provechosa. Por ejemplo, saber que una 
substancia impide el crecimiento de una bacteria infecciosa permite erradicar 
una enfermedad---es el caso de la penicilina.

La mecánica cuántica puede emplearse para describir sistemas cuidadosamente 
diseñados para que se comporten como un mecanismo de cálculo. Actualmente los 
ordenadores emplean nuestro conocimiento de las leyes físicas como el 
electromagnetismo para realizar cómputos. Del mismo modo, se pueden emplear 
sistemas cuánticos dando lugar al término ordenador cuántico. La idea de 
construir tal dispositivo ha sido propuesta por primera vez por Richard Feynman 
en 1982 \cite{feynman-sim}, con el objetivo de simular sistemas cuánticos.

\subsection{Computación cuántica}
La computación cuántica es un nuevo paradigma de computación, que busca la
resolución de problemas empleando las propiedades de la mecánica cuántica.
Fundamenta su utilidad en el hecho de que algunos problemas que tienen una alta
complejidad en los ordenadores clásicos, y son intratables, pasan a ser
tratables en un ordenador cuántico.

Peter Shor descubrió en 1994 \cite{shor97} como resolver el problema de 
factorización de un número compuesto en el producto de dos primos, como $15 = 
3\cdot5$. La complejidad de este cómputo es tan alta para números elevados, que 
se considera como base para algunos métodos de criptografía de como RSA. Se 
supone que nadie sería capaz de encontrar esos dos números primos en mucho 
tiempo. Pero empleando un ordenador cuántico, el tiempo se reduce lo suficiente 
como para encontrarlos. De modo que la criptografía tendría que buscar otros 
métodos.

La factorización de números mediante algoritmos cuánticos se ha llevado a cabo 
de forma experimental, siendo el número 56153 el más grande hasta la fecha 
\cite{factor}. 

Otro algoritmo cuántico fue descubierto en 1996 por Lov Grover \cite{grover96} 
para encontrar un elemento en una lista desordenada de tamaño $n$ con una 
probabilidad de $1/2$.  Mejorando el tiempo empleado por el mejor algoritmo 
probabilístico conocido de $O(n)$ a $O(\sqrt{n})$.

Una de las dificultades a la hora de diseñar un algoritmo cuántico es la gran 
diferencia de comportamiento, comparado con un algoritmo convencional o clásico.  
Nuestra intuición y formas actuales para diseñar algoritmos, fallan al tratar de 
comprender el proceso. Este es quizás uno de los motivos por los cuales no se 
han descubierto muchos algoritmos cuánticos \cite{shor03}.

\subsection{El bit y el qubit}
La forma de almacenar la información en un ordenador cuántico difiere en algunos 
aspectos a la forma en la que se almacena actualmente en los ordenadores 
convencionales.

\subsubsection{Bit clásico}
%Explicar lo que es un bit, y diferenciar entre el estado interno y lo que 
%representa
En los ordenadores actuales, la unidad básica de representación de información 
es el bit. La palabra bit significa dígito binario, que puede ser 0 o 1. Es el 
nexo de unión entre los sistemas físicos que implementan un bit, y una lógica 
binaria, que se abstrae de su implementación.

La forma en la que se implementa un bit depende de la arquitectura: la posición 
de una leva mecánica en la máquina, la existencia de una presilla en una cinta 
de vídeo (o también de cinta adhesiva), el estado de un interruptor, la 
presencia o ausencia de un agujero en una tarjeta perforada, anillos de ferrita 
que se magnetizan en un sentido o en otro, dos niveles de voltaje diferentes...

Todas estas representaciones, diferentes en su naturaleza física, comparten dos 
propiedades en común; es posible representar dos estados diferentes, y además es 
posible modificar y leer el estado en el que se encuentra el sistema.

De esta forma es importante distinguir entre la \textit{representación física} y 
el \textit{significado lógico}. En el caso de la tarjeta perforada, esta 
relación puede darse de la siguiente forma: Si hay un agujero, entonces 
representa un 0; en caso contrario, un 1. Para representar un bit, se empleará 
un estado $x \in \{0, 1\}$.


\subsubsection{Bit probabilístico}
%Introducir la analogía de una moneda para diferenciar entre el estado de la 
%moneda que es 0.5/0.5 mientras no se mide, y una vez "colapsa". Expresar la 
%probabilidad en forma de vector

Una moneda perfecta que se lanza al aire, y que cae sobre una superficie lisa, 
saca cara con igual probabilidad que cruz. Mientras se encuentra en el aire 
dando vueltas, su estado no es ni cara ni cruz. Es un estado diferente. Este 
estado puede representarse mediante un bit probabilístico, de forma que la cara 
es el 0, la cruz es el 1, y ambos tienen una probabilidad de 0.5 de ocurrir.  
Escribiendo las probabilidades en un vector, se define
%
$$ y = \mat{0.5 \\ 0.5} $$
%
Comenzando la numeración en 0, el primer elemento $y[0]$ representa la 
probabilidad de que el sistema saque un 0. Y $y[1]$ de que saque un 1. El hecho 
de que el índice coincida con el estado que representa, será útil en el futuro.

Además, debido a que se trata de un sistema probabilístico, ambas probabilidades 
han de sumar la unidad.
%
$$ y[0] + y[1] = 1 $$
%
Una vez que la moneda cae, su estado deja de ser un bit probabilístico $y$, y se 
convierte en un bit clásico $x$. Esta operación es la \textit{medición} de un 
sistema probabilístico.

\subsubsection{Bit cuántico o qubit}
%Extender el ejemplo de la moneda con la amplitud en vez de la probabilidad, y 
%explicar la notación en forma de vector

Hasta ahora, la clase de sistemas que se han descrito, son conocidos por 
experiencias en la vida cotidiana o profesional, y sirven de analogías. Sin 
embargo, el funcionamiento del sistema que se describirá a continuación no tiene 
un ejemplo conocido, tan sólo la imaginación será capaz de construir dicho 
sistema.

Un sistema cuántico puede encontrarse en un estado $z$, definido como
%
$$ z = \mat{\alpha \\ \beta}$$
%
Además, tanto $\alpha$ como $\beta$ son números complejos. Este estado se 
denomina bit cuántico o qubit.
%
Tras medir un qubit, el sistema se convertirá en un bit clásico $x$, con una 
probabilidad de que salga 0 de $|\alpha|^2$ y de que salga 1 de $|\beta|^2$.
Es decir, que se comportará como un bit probabilístico con las probabilidades
%
$$ y = \mat{|\alpha|^2 \\ |\beta|^2}$$
%
Y de igual modo, cumple la restricción de que ambas probabilidades suman la 
unidad:
%
$$ |\alpha|^2 + |\beta|^2 = 1 $$
%
Los números $\alpha$ y $\beta$ se denominan \textit{amplitudes}, y tienen 
asociada una probabilidad que es $|\alpha|^2$ y $|\beta|^2$ respectivamente.

\subsection{Múltiples qubits}
% Combinar dos bits para representar 4 estados, dos monedas para 4 estados
% probabilísticos, y 2 qubits para un 2-qubit.
Un sistema de dos monedas perfectas $m_1$ y $m_2$ tiene exactamente cuatro 
posibles resultados tras lanzarlas al aire $\{00, 01, 10, 11\}$. Siendo cara el 
0, cruz el 1, y la cadena 01 que $m_1$ sale cara y $m_2$ sale cruz.

El número de resultados posibles aumenta con el número de monedas $n$ de la 
forma $2^n$. Si ambas monedas se describen como un bit probabilístico, se 
obtiene
$$ y_1 = \mat{0.5 \\ 0.5} \quad y_2 = \mat{0.5 \\ 0.5} $$
Siendo $y_i$ la descripción del estado de la moneda $m_i$. Entonces, la 
probabilidad de obtener cada uno de los cuatro diferentes estados al lanzar 
ambas, se puede describir en forma de vector.
Sea $y_i[k]$ la probabilidad de que la moneda $m_i$ salga $k$, entonces la 
probabilidad de que salga $k_1$ y luego $k_2$ será:
$$ y_1[k_1] \cdot y_2[k_2] $$
De modo que se puede construir un vector que describa todas las posibilidades:
$$ y = \mat{
	y_1[0] \cdot y_2[0] \\ y_1[0] \cdot y_2[1] \\
	y_1[1] \cdot y_2[0] \\ y_1[1] \cdot y_2[1]
}
= \mat{
	y_1[0] \cdot y_2 \\
	y_1[1] \cdot y_2
} $$
Esta operación se conoce como el producto tensorial y conocer sus propiedades
será fundamental.

\subsubsection{Producto tensorial}
\label{sss:producto-tensorial}

La operación $\otimes$ se define como el producto tensorial o producto de 
Kronecker. Si A y B son dos matrices de $n \times m$ y $k \times l$ 
respectivamente:
%
$$
\begin{array}{c c}
	A=\mat{
		a_{11} & \cdots & a_{1m} \\
		\vdots &        & \vdots \\
		a_{n1} & \cdots & a_{nm}
	}
	,\quad
	&
	B=\mat{
		b_{11} & \cdots & b_{1l} \\
		\vdots &        & \vdots \\
		b_{k1} & \cdots & b_{kl}
	}
\end{array}
$$
%
Entonces $C = A \otimes B$ es la matriz $C$ de $nk \times ml$, definida como
%
$$
C = A \otimes B=\mat{
	a_{11} B & \cdots & a_{1m} B \\
	\vdots   &        & \vdots   \\
	a_{n1} B & \cdots & a_{nm} B
}
$$
%
El producto tensorial cumple varias propiedades interesantes.
%
\begin{itemize}
\item Es asociativo $(A \otimes B) \otimes C = A \otimes (B \otimes C)$

\item Es distributivo respecto a la suma $A \otimes (B + C) = (A \otimes B) + (A
\otimes C) $ y $(A + B) \otimes C = (A \otimes C) + (B \otimes C)$

\item Para un escalar $k$, cumple $(kA) \otimes B = A \otimes (kB) = k (A 
\otimes B)$
\end{itemize}
%
Pero en general, no es conmutativo: $A \otimes B \neq B \otimes A$.

\subsubsection{Monedas y qubits}

Empleando la notación de producto tensorial, ahora calcular el estado global de 
un sistema de dos monedas, se simplifica a
%
$$ y = y_1 \otimes y_2 $$
%
Este mismo procedimiento se emplea en la descripción de qubits. Un sistemai $z$ 
de dos qubits $z_1$ y $z_2$ se puede describir como:
%
$$
z_1 = \mat{\alpha_1 \\ \beta_1}, \quad
z_2 = \mat{\alpha_2 \\ \beta_2}, \quad
z = z_1 \otimes z_2 $$
%
De forma que se obtiene:
%
$$
z = \mat{\alpha_1 \alpha_2 & \alpha_1 \beta_2
	& \alpha_2 \beta_1 & \alpha_2 \beta_2}^T $$
%
Por ahora no hay ninguna diferencia apreciable en la forma en la que comporta un 
sistema cuántico frente a uno probabilístico. Pero no será durante mucho tiempo.
El sistema de dos monedas $y$ está sujeto a la restricción de que al lanzar una 
moneda la suma de las probabilidades de los posibles resultados debe ser la 
unidad, esto es
%
$$ y_1[0] + y_1[1] = 1, \quad y_2[0] + y_2[1] = 1$$
%
Cuando dos qubits se tratan por separado, esta restricción es análoga:
%
$$|\alpha_1|^2 + |\beta_1|^2 = 1, \quad |\alpha_2|^2 + |\beta_2|^2 = 1$$
%
Pero cuando se combinan en un sólo sistema cuántico, pasa a denominarse 
\textit{registro cuántico}, y la restricción se convierte en:
\begin{equation}
\label{eq:qbits-unidad}
\sum_{\alpha \in z} |\alpha|^2 = 1
\end{equation}
%
Permitiendo el caso en el que puede existir un registro con el estado:
$$ z = \mat{\frac{1}{\sqrt{2}} & 0 & 0 & \frac{1}{\sqrt{2}}}^T $$
Que cumple la restricción \eqref{eq:qbits-unidad} puesto que:
$$ \abs{\frac{1}{\sqrt{2}}}^2 + \abs{\frac{1}{\sqrt{2}}}^2 = \frac{1}{2} + 
\frac{1}{2} = 
1 $$
Y sin embargo, $z$ no puede ser expresado como el producto tensorial de dos 
qubits $z_1$ y $z_2$:
$$ z = z_1 \otimes z_2 = \mat{\alpha_1 \alpha_2 & \alpha_1 \beta_2
	& \alpha_2 \beta_1 & \alpha_2 \beta_2}^T = \mat{\frac{1}{\sqrt{2}} & 0 & 
	0 & \frac{1}{\sqrt{2}}}^T
$$
Se obtiene que $\alpha_1 \alpha_2 = \frac{1}{\sqrt{2}}$, por lo que $\alpha_1 
\neq 0$, y $\alpha_2 \beta_2 = \frac{1}{\sqrt{2}}$ entonces $\beta_2 \neq 0$ 
pero sin embargo $\alpha_1 \beta_2 = 0$, lo cual es imposible.

Este extraño suceso no existe en el mundo clásico, y no se puede realizar con 
las monedas. Es único en el mundo cuántico. Se denomina \textit{entrelazamiento 
cuántico} cuando un sistema cuántico compuesto no puede ser descrito mediante el 
producto de sus constituyentes. Se dice que se encuentra entrelazado.


\subsection{Operador}

Un sistema clásico puede contener varios bits, de forma que el número de 
posibles estados en los que se puede encontrar es $2^n$ para $n$ bits. Por 
ejemplo, en una tarjeta perforada del telar de Jacquard de $8$ filas por 26 
columnas, con un total de 208 celdas, existen $2^{208} \approx 
4.11 \cdot 10^{62}$ posibles combinaciones.

Si se emplean 108 monedas, el número de posibles combinaciones de cara y cruz 
sería el mismo. Sin embargo, justo antes de caer, el sistema se encuentra en un 
estado en el que cada posible combinación tiene la misma probabilidad de 
ocurrir. Del mismo modo que para un bit probabilístico, para $n$ se puede 
emplear un vector $y$ que describa la probabilidad para cada estado posible
$$
	y = \mat{y_0 & \cdots & y_{2^n-1}}^T
$$

\subsection{Registros cuánticos}
Para almacenar más de un qbit se emplean los registros cuánticos, que son 
análogos a los registros clásicos de $n$ bits.

Sin embargo difieren de los registros clásicos de bits. En uno clásico, el 
registro se encuentra siempre en un estado determinado. Para $n$ bits, existen 
$2^n$ estados posibles, y el registro se encuentra en uno de ellos. Sin embargo 
en uno cuántico, no sólo puede encontrarse en todos esos estados, si no también 
en superposición. Esto es, que se encuentra en una mezcla de varios estados. O 
incluso de todos ellos.

\subsubsection{Superposición}






Para representar $N$ bits, es suficiente con un vector $\boldsymbol{b} = 
\mat{b_0 & b_1 & \cdots & b_{N-1} }^T$. De forma que $b_i \in \{0,1\}$. Por 
ejemplo un byte, que está formado de 8 bits, es:
$$\mat{b_0 & b_1 & b_2 & b_3 & b_4 & b_5 & b_6 & b_7}^T$$
Simplificando la notación, representando solo los bits:
$$\boldsymbol{b} = b_0 \, b_1 \, b_2 \, b_3 \, b_4 \, b_5 \, b_6 \, b_7$$
Por lo que $\boldsymbol{b} \in \{0,1\}^N$, y numerando cada vector con:
$$d = \sum_i 2^i b_i$$
Por ejemplo $d=14$ es $\boldsymbol{b} = 1110$ con $N=4$. $1110_b = 14_d$
Por ejemplo $11000001_b = 193_d$


\subsection{Operaciones}



Para realizar una operación sobre un estado cuántico, se emplea un operador 
expresado por una matriz.

Por ejemplo, la puerta NOT que invierte el estado de un bit, tiene una operación 
análoga en la computación cuántica.
%
$$ NOT = \mat{0 & 1 \\ 1 & 0} $$
%
De modo que al aplicarla sobre un estado $\ket{\psi} = \mat{\alpha & \beta}^T$, 
se obtiene:
%
$$ NOT \ket{\psi} = \mat{0 & 1 \\ 1 & 0} \mat{\alpha \\ \beta} = \mat{\beta \\ 
\alpha} $$
%
Las amplitudes se han invertido, de forma análoga a un estado clásico. Si 
$\ket{\psi} = \ket{0}$, entonces $NOT\ket{0} = NOT \mat{1 & 0}^T = \mat{0 & 
1}^T = \ket{1}$. Y de igual forma para $NOT \ket{1} = \ket{0}$.
