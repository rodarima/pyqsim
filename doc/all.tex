\input{preamble}
\begin{document}

\section{Introducción a la computación cuántica}
\subsection{Preliminares}
La computación cuántica es un nuevo paradigma de computación, que busca la
resolución de problemas empleando las propiedades de la mecánica cuántica.

Fundamenta su utilidad en el hecho de que algunos problemas que tienen una alta
complejidad en los ordenadores clásicos, y son intratables, pasan a ser
tratables en un ordenador cuántico.

\subsection{El bit y el qubit}

\subsubsection{Bit clásico}
%Explicar lo que es un bit, y diferenciar entre el estado interno y lo que 
%representa
En los ordenadores actuales, la unidad básica de representación de información 
es el bit. La palabra bit significa dígito binario, que puede ser 0 o 1. Es el 
nexo de unión entre los sistemas físicos que implementan un bit, y una lógica 
binaria, que se abstrae de su implementación.

La forma en la que se implementa un bit depende de la arquitectura: la posición 
de una leva mecánica en la máquina, la existencia de una presilla en una cinta 
de vídeo (o también de cinta adhesiva), el estado de un interruptor, la 
presencia o ausencia de un agujero en una tarjeta perforada, anillos de ferrita 
que se magnetizan en un sentido o en otro, dos niveles de voltaje diferentes...

Todas estas representaciones, diferentes en su naturaleza física, comparten dos 
propiedades en común; es posible representar dos estados diferentes, y además es 
posible modificar y leer el estado en el que se encuentra el sistema.

De esta forma es importante distinguir entre la \textit{representación física} y 
el \textit{significado lógico}. En el caso de la tarjeta perforada, esta 
relación puede darse de la siguiente forma: Si hay un agujero, entonces 
representa un 0; en caso contrario, un 1. Para representar un bit, se empleará 
un estado $x \in \{0, 1\}$.


\subsubsection{Bit probabilístico}
%Introducir la analogía de una moneda para diferenciar entre el estado de la 
%moneda que es 0.5/0.5 mientras no se mide, y una vez "colapsa". Expresar la 
%probabilidad en forma de vector

Una moneda perfecta que se lanza al aire, y que cae sobre una superficie lisa, 
saca cara con igual probabilidad que cruz. Mientras se encuentra en el aire 
dando vueltas, su estado no es ni cara ni cruz. Es un estado diferente. Este 
estado puede representarse mediante un bit probabilístico, de forma que la cara 
es el 0, la cruz es el 1, y ambos tienen una probabilidad de 0.5 de ocurrir.  
Escribiendo las probabilidades en un vector, se define
%
$$ y = \mat{0.5 \\ 0.5} $$
%
Comenzando la numeración en 0, el primer elemento $y[0]$ representa la 
probabilidad de que el sistema saque un 0. Y $y[1]$ de que saque un 1. El hecho 
de que el índice coincida con el estado que representa, será útil en el futuro.

Además, debido a que se trata de un sistema probabilístico, ambas probabilidades 
han de sumar la unidad.
%
$$ y[0] + y[1] = 1 $$
%
Una vez que la moneda cae, su estado deja de ser un bit probabilístico $y$, y se 
convierte en un bit clásico $x$. Esta operación es la \textit{medición} de un 
sistema probabilístico.

\subsubsection{Bit cuántico o qubit}
%Extender el ejemplo de la moneda con la amplitud en vez de la probabilidad, y 
%explicar la notación en forma de vector

Hasta ahora, la clase de sistemas que se han descrito, son conocidos por 
experiencias en la vida cotidiana o profesional, y sirven de analogías. Sin 
embargo, el funcionamiento del sistema que se describirá a continuación no tiene 
un ejemplo conocido, tan sólo la imaginación será capaz de construir dicho 
sistema.

Un sistema cuántico puede encontrarse en un estado $z$, definido como
%
$$ z = \mat{\alpha \\ \beta}$$
%
Además, tanto $\alpha$ como $\beta$ son números complejos. Este estado se 
denomina bit cuántico o qubit.
%
Tras medir un qubit, el sistema se convertirá en un bit clásico $x$, con una 
probabilidad de que salga 0 de $|\alpha|^2$ y de que salga 1 de $|\beta|^2$.
Es decir, que se comportará como un bit probabilístico con las probabilidades
%
$$ y = \mat{|\alpha|^2 \\ |\beta|^2}$$
%
Y de igual modo, cumple la restricción de que ambas probabilidades suman la 
unidad:
%
$$ |\alpha|^2 + |\beta|^2 = 1 $$
%
Los números $\alpha$ y $\beta$ se denominan \textit{amplitudes}, y tienen 
asociada una probabilidad que es $|\alpha|^2$ y $|\beta|^2$ respectivamente.

\subsection{Múltiples qubits}
% Combinar dos bits para representar 4 estados, dos monedas para 4 estados
% probabilísticos, y 2 qubits para un 2-qubit.

\subsection{Operador}

Un sistema clásico puede contener varios bits, de forma que el número de 
posibles estados en los que se puede encontrar es $2^n$ para $n$ bits. Por 
ejemplo, en una tarjeta perforada del telar de Jacquard de $8$ filas por 26 
columnas, con un total de 208 celdas, existen $2^{208} \approx 
4.11 \cdot 10^{62}$ posibles combinaciones.

Si se emplean 108 monedas, el número de posibles combinaciones de cara y cruz 
sería el mismo. Sin embargo, justo antes de caer, el sistema se encuentra en un 
estado en el que cada posible combinación tiene la misma probabilidad de 
ocurrir. Del mismo modo que para un bit probabilístico, para $n$ se puede 
emplear un vector $y$ que describa la probabilidad para cada estado posible
$$
	y = \mat{y_0 & \cdots & y_{2^n-1}}^T
$$

\subsection{Registros cuánticos}
Para almacenar más de un qbit se emplean los registros cuánticos, que son 
análogos a los registros clásicos de $n$ bits.

Sin embargo difieren de los registros clásicos de bits. En uno clásico, el 
registro se encuentra siempre en un estado determinado. Para $n$ bits, existen 
$2^n$ estados posibles, y el registro se encuentra en uno de ellos. Sin embargo 
en uno cuántico, no sólo puede encontrarse en todos esos estados, si no también 
en superposición. Esto es, que se encuentra en una mezcla de varios estados. O 
incluso de todos ellos.

\subsubsection{Superposición}


\subsubsection{Producto tensorial}
\label{sss:producto-tensorial}

La operación $\otimes$ se define como el producto tensorial o producto de 
Kronecker. Si A y B son dos matrices de $n \times m$ y $k \times l$ 
respectivamente:
%
$$
\begin{array}{c c}
	A=\mat{
		a_{11} & \cdots & a_{1m} \\
		\vdots &        & \vdots \\
		a_{n1} & \cdots & a_{nm}
	}
	,\quad
	&
	B=\mat{
		b_{11} & \cdots & b_{1l} \\
		\vdots &        & \vdots \\
		b_{k1} & \cdots & b_{kl}
	}
\end{array}
$$
%
Entonces $C = A \otimes B$ es la matriz $C$ de $nk \times ml$, definida como
%
$$
C = A \otimes B=\mat{
	a_{11} B & \cdots & a_{1m} B \\
	\vdots   &        & \vdots   \\
	a_{n1} B & \cdots & a_{nm} B
}
$$
%
El producto tensorial cumple varias propiedades interesantes.
%
\begin{itemize}
\item Es asociativo $(A \otimes B) \otimes C = A \otimes (B \otimes C)$

\item Es distributivo respecto a la suma $A \otimes (B + C) = (A \otimes B) + (A
\otimes C) $ y $(A + B) \otimes C = (A \otimes C) + (B \otimes C)$

\item Para un escalar $k$, cumple $(kA) \otimes B = A \otimes (kB) = k (A 
\otimes B)$
\end{itemize}
%
Pero en general, no es conmutativo: $A \otimes B \neq B \otimes A$.





Para representar $N$ bits, es suficiente con un vector $\boldsymbol{b} = 
\mat{b_0 & b_1 & \cdots & b_{N-1} }^T$. De forma que $b_i \in \{0,1\}$. Por 
ejemplo un byte, que está formado de 8 bits, es:
$$\mat{b_0 & b_1 & b_2 & b_3 & b_4 & b_5 & b_6 & b_7}^T$$
Simplificando la notación, representando solo los bits:
$$\boldsymbol{b} = b_0 \, b_1 \, b_2 \, b_3 \, b_4 \, b_5 \, b_6 \, b_7$$
Por lo que $\boldsymbol{b} \in \{0,1\}^N$, y numerando cada vector con:
$$d = \sum_i 2^i b_i$$
Por ejemplo $d=14$ es $\boldsymbol{b} = 1110$ con $N=4$. $1110_b = 14_d$
Por ejemplo $11000001_b = 193_d$


\subsection{Operaciones}



Para realizar una operación sobre un estado cuántico, se emplea un operador 
expresado por una matriz.

Por ejemplo, la puerta NOT que invierte el estado de un bit, tiene una operación 
análoga en la computación cuántica.
%
$$ NOT = \mat{0 & 1 \\ 1 & 0} $$
%
De modo que al aplicarla sobre un estado $\ket{\psi} = \mat{\alpha & \beta}^T$, 
se obtiene:
%
$$ NOT \ket{\psi} = \mat{0 & 1 \\ 1 & 0} \mat{\alpha \\ \beta} = \mat{\beta \\ 
\alpha} $$
%
Las amplitudes se han invertido, de forma análoga a un estado clásico. Si 
$\ket{\psi} = \ket{0}$, entonces $NOT\ket{0} = NOT \mat{1 & 0}^T = \mat{0 & 
1}^T = \ket{1}$. Y de igual forma para $NOT \ket{1} = \ket{0}$.

\newpage
\section{Algoritmo de Simon}
\subsection{Descripción del problema}

Daniel R. Simon encontró un problema que presentaba una complejidad exponencial 
al tratar de resolverse mediante métodos de computación tradicionales. Sin 
embargo, al abordarlo mediante una solución cuántica, dicha complejidad 
disminuía de orden, a una lineal.

El problema consiste en encontrar una cadena binaria desconocida, denominada 
$s$, que contiene $n$ bits, relacionada con una función $f$. Sea $V$ el conjunto 
de cadenas de $n$ bits, $V = \{0,1\}^n$, entonces la función $f$ asigna a cada 
cadena de $V$ otra cadena del mismo conjunto, $f:V \rightarrow V$.

Además la función cumple la restricción
%
\begin{equation}
	\label{eq:simon_f}
	f(x_1) = f(x_2) \iff x_1 = x_2 \oplus s
\end{equation}
%
Por una parte, si el resultado de dos salidas es idéntico, es decir $f(x_1) = 
f(x_2)$ entonces entradas deben cumplir que $x_1 = x_2 \oplus s$:
%
$$ f(x_1) = f(x_2) \implies x_1 = x_2 \oplus s $$
%
Y por otra parte, si dos pares de entradas cumplen $x_1 = x_2 \oplus s$ entonces 
sus salidas serán idénticas:
%
$$ x_1 = x_2 \oplus s \implies f(x_1) = f(x_2) $$
%
Con un ejemplo de 2 bits, y una cadena $s = 01$, se define $f$:
%
\begin{center}
\begin{tabular}{|c|c||c|c|}
	\hline
	$x$ & $f(x)$ & $x \oplus s$ & $f(x \oplus s)$\\
	\hline
	00 & 00 & 01 & 00\\
	01 & 00 & 00 & 00\\
	10 & 01 & 11 & 01\\
	11 & 01 & 10 & 01\\
	\hline
\end{tabular}
\end{center}
%
Se observa que $f(x)$ es idéntico a $f(x \oplus s)$, de modo que esta función 
cumple los requisitos para el problema.

\subsubsection{Solución clásica}

Una solución clásica consistiría en evaluar $f$ con entradas diferentes hasta 
encontrar una entrada $x_1$ que produzca una salida que ya se hubiera observado 
con otra entrada $x_2$. Entonces, debido a la restricción \ref{eq:simon_f} se 
tiene que $x_2 = x_1 \oplus s$, y por lo tanto se puede calcular $s$ como $s = 
x_1 \oplus x_2$.

Debido a que dos entradas producen la misma salida, y que todas las posibles 
entradas forman pares de la forma $x_2 = x_1 \oplus s$, la función $f$ tendrá la 
mitad de sus salidas iguales. Es decir, que sólo existen $2^{n/2}$ salidas 
diferentes, por lo que al evaluar una más, $2^{n/2} + 1$ se asegura encontrar 
dos entradas que produzcan la misma salida. De esta forma la complejidad se 
sitúa en $\mathcal{O}(2^{n/2})$.

Esta solución tiene el inconveniente de ser muy costosa computacionalmente, dado 
que para encontrar una coincidencia en la salida es necesario evaluar la función 
un número exponencial de veces con respecto al número de bits $n$.

Empleando la función del ejemplo, bastaría con evaluarla $k$ veces con
$$k = 2^{2/2}+1 = 3$$
Entonces si $y_i = f(x_i)$, se obtiene $\V x = \mat{00 & 01 & 10}$ y $ \V y = 
\mat{00 &00 & 01}$.  Como se puede observar $y_1 = y_2$, de modo que $x_1 = x_2 
\oplus s$, y por lo tanto $s = x_1 \oplus x_2 = 00 \oplus 01 = 01$

\subsection{Solución cuántica}
%
El algoritmo de Simon consiste en un circuito cuántico con dos líneas, cada una
de $n$ qubits.
%
\begin{center}
	\begin{tikzpicture}%[thick]
	% `operator' will only be used by Hadamard (H) gates here.
	\tikzstyle{operator} = [draw,fill=white,minimum size=1.5em] 
	%
	\matrix[row sep=0.4cm, column sep=1cm] (circuit) {
		% First row
		\node (q1) {$\ket{0^n}$}; &
		\node[operator] (H11) {$H^{\otimes n}$}; &
		\node[operator] (P13) {}; &
		\node[operator] (H11) {$H^{\otimes n}$}; &
		\node[operator] (M11) {$M$};&
		\coordinate (end1); \\
		% Second row.
		\node (q2) {$\ket{0^n}$}; & & \node[operator] (P23) {}; & & & \coordinate (end2);\\
		% Third row
		\node (q31) {}; & \node (q32) {}; & \node (q33) {}; &
		\node (q34) {}; & \node (q35) {}; & \node (q36) {}; \\
		\node (q41) {}; & \node (q42) {}; & \node (q43) {}; &
		\node (q44) {}; & \node (q45) {}; & \node (q46) {}; \\
	};
	\node[operator] (Us) [fit = (P13) (P23), minimum width=1cm] {$U_s$};

	\node (arr0) [fit = (q31) (q32)] {$\uparrow$};
	\node (arr1) [fit = (q32) (q33)] {$\uparrow$};
	\node (arr2) [fit = (q33) (q34)] {$\uparrow$};
	\node (arr3) [fit = (q34) (q35)] {$\uparrow$};

	\node (psi0) [fit = (q41) (q42)] {$\ket{\psi_0}$};
	\node (psi1) [fit = (q42) (q43)] {$\ket{\psi_1}$};
	\node (psi2) [fit = (q43) (q44)] {$\ket{\psi_2}$};
	\node (psi3) [fit = (q44) (q45)] {$\ket{\psi_3}$};

	\node[fill=white, fit=(end1) (end2)] (cover) {};

	\begin{pgfonlayer}{background}
		% Draw lines.
		\draw (q1) -- (M11)  (q2) -- (end2);
		\draw[double, double distance=2pt] (M11) -- (end1);
	\end{pgfonlayer}

	%
	\end{tikzpicture}
\end{center}
%
Primero el sistema se inicia con ambas líneas a $\ket{0^n}$. Luego se aplica un 
operador de Hadamard sobre la primera, que creará una superposición de estados.  
Posteriormente, el operador $U_s$ computa los resultados de la función $f$ de 
forma simultánea. Para terminar, se revierte el operador de Hadamard sobre la 
primera línea, que finalmente se mide.

Los estados asociados a cada paso de la computación, han sido etiquetados como 
$\ket{\psi_i}$, de forma que en todo momento se pueda determinar el lugar al que 
corresponden en el circuito.

\subsection{Funcionamiento}
Para comprender el funcionamiento del algoritmo, se empleará un ejemplo sencillo 
con sólo dos bits, $n=2$ y de período $s=01$:
%
\begin{center}
\begin{tabular}{|c|c|}
	\hline
	$x$ & $f(x)$ \\
	\hline
	00 & 00 \\
	01 & 00 \\
	10 & 01 \\
	11 & 01 \\
	\hline
\end{tabular}
\end{center}
%
Sea $V = \{0,1\}^n$ entonces $f:V\rightarrow V$ y $f(x) = f(x\oplus s)$. De esta 
forma, $f(00) = f(00 \oplus s) = f(01)$ y también $f(10) = f(10 \oplus s) = 
f(11)$.

El sistema ha de iniciarse con ambas líneas a $\ket{0^n}$, de modo que:
%
$$ \ket{\psi_0} = \ket{0^n} \otimes \ket{0^n} $$
%
A continuación, el operador de Hadamard es aplicado sobre la línea superior.
%
\begin{equation}
\begin{split}
\ket{\psi_1} & = (H^{\otimes n} \otimes I^{\otimes n}) \ket{\phi_0} \\
	& = (H^{\otimes n} \otimes I^{\otimes n}) (\ket{0^n} \otimes \ket{0^n}) \\
	& = (H^{\otimes n} \ket{0^n}) \otimes (I^{\otimes n} \ket{0^n}) \\
	& = \frac{1}{\sqrt{2^n}} \sum_{x \in V} \ket{x, 0^n}
\end{split}
\end{equation}
%
Produciendo el estado entrelazado
%
\begin{equation}
\ket{\psi_1} = \frac{1}{\sqrt{2^2}} (\ket{00,00} + \ket{01,00} + \ket{10,00} + 
\ket{11,00})
\end{equation}
%
Posteriormente, la puerta $U_s$ actúa sobre $\ket{\psi_1}$ transformándolo en
%
\begin{equation}
\ket{\psi_2} = \frac{1}{\sqrt{2^n}} \sum_{x \in V} \ket{x, f(x) \oplus 00} = 
\frac{1}{\sqrt{2^n}} \sum_{x \in V} \ket{x, f(x)}
\end{equation}
%
En este estado, la función $f$ está siendo evaluada simultáneamente en todo $V$, 
y este efecto será clave para la reducción de complejidad. Con la función $f$ 
previamente descrita, dicho estado es
%
\begin{equation}
\ket{\psi_2} = \frac{1}{\sqrt{2^2}} (\ket{00,00} + \ket{01,00} + \ket{10,01} + 
\ket{11,01})
\end{equation}
%
Finalmente, el operador de Hadamard es nuevamente aplicado sobre la línea 
superior, de este modo se obtiene
% TODO: Explicar el origen de esta expresion
\begin{equation}
\ket{\psi_3} = \frac{1}{2^n} \sum_{x \in V} \sum_{z \in V}
	(-1)^{\braket{z|x}} \ket{z, f(x)}
\end{equation}
%
Por consiguiente, el coeficiente de cada ket será
%
\begin{equation}
c_k = \frac{1}{2^n} (-1)^{\braket{z|x}}
\end{equation}
%
Pero dado que $f(x) = f(x \oplus s)$, los kets $\ket{z, f(x)}$ y $\ket{z, f(x 
\oplus s)}$ serán el mismo, por lo que el coeficiente para este ket será
%
\begin{equation}
c_k = \frac{1}{2^n} \left((-1)^{\braket{z|x}} + (-1)^{\braket{z|x \oplus 
s}}\right)
\end{equation}
%
El producto interno $\braket{z|x \oplus s}$ puede descomponerse en $\braket{z|x} 
\oplus \braket{z|s}$, y substituyendo
%
\begin{equation}
\begin{split}
c_k & = \frac{1}{2^n} \left((-1)^{\braket{z|x}} + (-1)^{\braket{z|x} \oplus 
\braket{z|s}} \right) \\
	& = \frac{1}{2^n} \left((-1)^{\braket{z|x}} + (-1)^{\braket{z|x}}
	(-1)^{\braket{z|s}} \right)
\end{split}
\end{equation}
%
Cuando $\braket{z|s} = 1$, el coeficiente $c_k$ será
%
\begin{equation}
\begin{split}
c_k = \frac{1}{2^n} \left((-1)^{\braket{z|x}} - (-1)^{\braket{z|x}} \right) =
	\frac{1}{2^n} (0) = 0
\end{split}
\end{equation}
%
Y cuando $\braket{z|s} = 0$, será
%
\begin{equation}
c_k = \frac{1}{2^n} \left((-1)^{\braket{z|x}} + (-1)^{\braket{z|x}} \right)
	= \frac{1}{2^n} (\pm 2) = \pm 2^{1-n}
\end{equation}
%
De modo que $c_k \neq 0$ si en el ket $\ket{z, f(x)}$ se cumple que 
$\braket{z|s} = 0$. Así que sólo los estados de esta forma tendrán coeficientes 
no nulos. En el caso del ejemplo será
%
\begin{equation}
\begin{split}
\ket{\psi_3} = 2^{-n} \big( &
		+ \ket{00,00} + \ket{01,00} + \ket{10,00} + \ket{11,00} \\
	& + \ket{00,00} - \ket{01,00} + \ket{10,00} - \ket{11,00} \\
	& + \ket{00,01} + \ket{01,01} - \ket{10,01} - \ket{11,01} \\
	& + \ket{00,01} - \ket{01,01} - \ket{10,01} + \ket{11,01}
	\big)
\end{split}
\end{equation}
%
Finalmente, tras anular los términos en los que $\braket{z|01} = 1$, es decir 
$z=01$ y $z=11$, queda
%
\begin{equation}
	\ket{\psi_3} = 2^{1-n} \left( \ket{00,00} + \ket{10,00} + \ket{00,01} - 
\ket{10,01} \right)
\end{equation}
%
En este estado, si se realiza una medición de $z$, el resultado siempre cumplirá 
la restricción $\braket{z|s} = 0$. Una vez que se obtengan $n-1$ vectores 
linealmente independientes, será posible construir un sistema de ecuaciones y 
calcular $s$.

En este ejemplo, después de medir la primera línea, el conjunto de vectores 
posibles resulta $z \in \{00, 10\}$. En todo caso, se tiene que $\braket{z|s} = 
0$ de modo que $\braket{00|s} = 0$ y $\braket{10|s} = 0$, produciendo las 
ecuaciones:
%
\begin{equation}
\begin{split}
	0 s_0 \oplus 0 s_1 = 0 \\
	1 s_0 \oplus 0 s_1 = 0
\end{split}
\end{equation}
%
Cuyas soluciones son $s \in \{00, 01\}$, pero dado que $s \neq 00$, se obtiene 
$s = 01$.

\subsection{Análisis de complejidad}

El algoritmo de Simon produce en la salida tras la medición, un vector $z$ que 
pertenece a un conjunto $W$, de forma que $W = \{z / \braket{z|s} = 0\}$ para 
todo $z \in V$.

En cuanto se obtienen $n-1$ vectores independientes, el proceso concluye, ya que 
es posible averiguar $s$. Sin embargo, todos los vectores de $W$ pueden salir 
con igual probabilidad, pues sus coeficientes $c_k$

El valor medio de ejecuciones $E[R]$, puede medir cual es la media de 
ejecuciones que son necesarias a la larga. Para calcularlo:

$$ E[R] = \sum^{\infty}_{x=1} x \cdot p(T, p=x) $$

\subsubsection{Probabilidad de terminar}

La probabilidad de terminar en $p$ pasos depende del número de bits $n$ y del 
número de vectores linealmente independientes $i$ ya obtenidos previamente.  
Expresando $p(\textrm{Terminar con $i$ vectores en $p$ pasos}) = p(T|i,p) = 
T^i_p$ 

$$T^i_p = I^i \, T^i_{p-1} + \overline{I^i} \, T^{i+1}_{p-1}$$

$$ T^i_p = \prod^{n-2}_{j=0} I^j \cdot 2^{(-n+1)(p-n+2)} \cdot {p-1 \choose 
p-n-1}_{q=2} $$


\end{document}
