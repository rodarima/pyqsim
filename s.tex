\documentclass{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage{braket}

% Vector
\newcommand*\mat[1]{ \begin{pmatrix} #1 \end{pmatrix}}
\newcommand*\arr[1]{ \begin{bmatrix} #1 \end{bmatrix}}

% Apartado de un ejemplo
\theoremstyle{definition}
\newtheorem{ejemplo}{Ejemplo}[section]


\begin{document}
Dado un $s$, la ecuación $s \cdot y = 0$ con $s, y \in \mathbb Z_2^n$ tiene 
varias soluciones para $y$.
$$ s \cdot y = s_0 \cdot y_0 + s_1 \cdot y_1 + \ldots + s_{n-1} \cdot y_{n-1} = 
\sum_{i}{s_i \cdot y_i} = 0$$
Si $s = 0$, entonces existen $2^n$ soluciones, dado que $s_i = 0$, y cualquier 
valor para $y$ satisface la ecuación.
$$ \sum_{i}{s_i \cdot y_i} = \sum_{i}{0 \cdot y_i} $$

$$ s_i \cdot y_i = 0 \cdot y_i = 0 \cdot 0 = 0 \cdot 1 = 0 = s_i$$
Si $s \neq 0$, entonces las posibles soluciones se reducen, ya que en algún caso 
$s_i = 1$, por lo que $s_i \cdot y_i = 1 \cdot y_i = y_i$.
En el caso en el que el número de unos en $s$ sea uno, para un $i$, $s_i = 1$, 
entonces $y_i = 0$, y el resto de componentes de $y$ podrán tomar cualquier 
valor. Resultando $2^{n-1}$ soluciones.

En caso de dos unos, en las posiciones $u_0$ y $u_1$, $s_{u_0} = s_{u_1} = 1, y 
s_{u_0}$

\section{Complejidad}

El algoritmo de Simon produce en la salida de cada simulación, un vector $y$ que
pertenece a un grupo predeterminado de vectores $Y$.

En cuanto se obtienen $n-1$ vectores independientes, el proceso concluye, ya que
es posible averiguar $s$. Sin embargo, todos los vectores de $Y$ pueden salir
con igual probabilidad. El valor medio de ejecuciones $E[R]$, puede medir cual
es la media de ejecuciones que son necesarias a la larga. Para calcularlo:

$$ E[R] = \sum^{\infty}_{x=1} x \cdot p(T, p=x) $$

\subsection{Probabilidad de terminar}

La probabilidad de terminar en $p$ pasos depende del número de bits $n$ y del 
número de vectores linealmente independientes $i$ ya obtenidos previamente.  
Expresando $p(\textrm{Terminar con $i$ vectores en $p$ pasos}) = p(T|i,p) = 
T^i_p$ 

$$T^i_p = I^i \, T^i_{p-1} + \overline{I^i} \, T^{i+1}_{p-1}$$

$$ T^i_p = \prod^{n-2}_{j=0} I^j \cdot 2^{(-n+1)(p-n+2)} \cdot {p-1 \choose 
p-n-1}_{q=2} $$

\section{Como almacenar grandes matrices}
A medida que crece el número de qubits $2n$, crece el espacio necesario para 
almacenar los operadores y los estados.

Un estado de $2n$ qubits, emplea un vector de $2^{2n}$ amplitudes. Un operador 
hermítico, requiere de $2^{2n} \cdot 2^{2n} = 2^{4n}$ elementos. Si $m = 
2^{2n}-1$:

$$ \ket{\phi_0} = \mat{e_0 \\ e_1 \\ \vdots \\ e_m},\, H =
	\mat{ u_{00} & u_{01} & \ldots & u_{0m} \\
		u_{10} & u_{11} & \ldots & u_{1m}\\
		\vdots & \vdots & \ddots & \vdots \\
		u_{m0} & u_{m1} & \ldots & u_{mm}\\
	}
$$

De modo que aplicar el operador $H$ sobre el estado $\ket{\phi_0}$, equivale a 
una multiplicación de una matriz por un vector:

$$ \ket{\phi_1} =
	H \ket{\phi_0} = \mat{ u_{00} & u_{01} & \ldots & u_{0m} \\
		u_{10} & u_{11} & \ldots & u_{1m}\\
		\vdots & \vdots & \ddots & \vdots \\
		u_{m0} & u_{m1} & \ldots & u_{mm}\\
	}
	\mat{e_0 \\ e_1 \\ \vdots \\ e_m}
$$

Sin embargo, en ocasiones $\ket{\phi_0}$ contiene muchos elementos que son cero, 
$e_i = 0$. ¿Es posible ignorar dichos elementos?.

$$ b_i = u_{i0} e_0 + u_{i1} e_1 + \ldots + u_{im} e_m =
	\sum_{j = 0}^{m} u_{ij} e_j
$$

Sea $J$ el conjunto de los índices de los elementos no nulos del estado 
$\ket{\phi_0}$, $ J = \{j \mid e_j \neq 0\} $.

$$ b_i = \sum_{j = 0}^{m} u_{ij} e_j =
	\sum_{j \notin J} u_{ij} 0 + \sum_{j \in J} u_{ij} e_j =
	\sum_{j \in J} u_{ij} e_j
$$

De modo que si $S_p$ es el tamaño que ocupa representar una posición del vector 
$\ket{\phi_0}$, $S_c$ el de un elemento, y $N_j$ es el número de elementos no 
nulos; Representar un estado almacenando sus filas contiguas requiere un espacio 
$nS_c$. Sin embargo, almacenar sólo los elementos no nulos con su posición, 
$N_j(S_p + S_c)$

Merece la pena cuando $mS_c > N_j(S_p + S_c)$, es decir, cuando el grado de 
ocupación $m/N_j$ sea grade:
$$m/N_j > \frac{S_p + S_c}{S_c}$$

Dado que generalmente los estados contienen un elevado número de elementos 
nulos, esta representación resulta muy conveniente.

% COO vs CSR

\subsection{Matrices huecas}

Si la matriz \textbf{A} contiene \textit{muchos} elementos nulos, se considera 
una matriz \textit{hueca}. Aprovechar esta propiedad permite: por una parte 
reducir el número de elementos que es necesario almacenar, y por otra, reducir 
el número de sumas y multiplicaciones al operar con la matriz.
$$ \textbf{A} = \mat{ a_{11} & \cdots & a_{1n} \\
		\vdots &   & \vdots \\
		a_{m1} & \cdots & a_{mn}\\
	}
$$

Sea $N_z$ el número de elementos no nulos de \textbf{A}. Entonces la 
\textit{densidad} de una matriz se define como dicho número entre el total, 
$N_z/mn$.

\subsubsection{Almacenamiento por coordenadas COO}

La matriz $\textbf{A} \in \mathbb{M}^{m\times n}$ puede almacenarse en tres 
vectores AA, JR y JC; de forma que AA contiene todos los elementos no nulos 
junto con JR y JC que almacenan los índices de la fila y columna 
respectivamente. Este esquema se conoce como almacenamiento por coordenadas 
(COO).

Sea $S_e$ y $S_i$ el tamaño de almacenamiento de un elemento de la matriz y de 
un índice respectivamente, entonces el espacio necesario es
$$ S_{COO} = S_eN_z + 2S_iN_z, $$
En comparación con la representación íntegra de la matriz, se conseguiría una 
reducción del espacio si
$$ N_z/mn < \frac{S_e}{S_e + 2S_i} $$

\begin{ejemplo}
La matriz \textbf{A} de $5\times5$ elementos, contiene 10 no nulos, de un total 
de 25, que se almacenan en el vector JA. A cada uno le corresponde un índice en 
JR que indica la fila, y otro en JR con la columna. El elemento 8 se encuenta en 
AA[7], JR[7] indica la tercera fila, y JC[7] la tercera columna.
$$ \textbf{A} = \mat{
	1 & 0 & 0 & 2 & 0 \\
	3 & 4 & 0 & 5 & 0 \\
	9 & 0 & \textbf{8} & 0 & 0 \\
	0 & 0 & 6 & 5 & 0 \\
	0 & 0 & 0 & 0 & 4 }
\quad
\begin{aligned}
	AA = \arr{ 1 & 2 & 3 & 4 & 5 & 9 & \textbf{8} & 6 & 5 & 4} \\
	JR = \arr{ 1 & 1 & 2 & 2 & 2 & 3 & \textbf{3} & 4 & 4 & 5} \\
	JC = \arr{ 1 & 4 & 1 & 2 & 4 & 1 & \textbf{3} & 3 & 4 & 5}
\end{aligned}
$$
\end{ejemplo}

\subsubsection{Almacenamiento por filas comprimidas (CSR)}

El almacenamiento por coordenadas contiene información redundante. Los elementos 
de la misma fila repiten el mismo índice en JR. Para reducir el espacio, se 
puede emplear sólo el índice en AA del primer elemento de cada fila.

De este modo, AA almacena los valores no nulos, ordenados por filas. El vector 
JA mantendrá las posiciones de las columnas para cada elemento de AA, y 
finalmente, IA, el índice en AA del primer elemento de la fila. Adicionalmente 
IA termina con un elemento extra, que indica el final de la última fila, con 
valor $N_z + 1$.

El tamaño necesario para almacenar una matriz de $m$ filas en CSR es
$$ S_{CSR} = S_e N_z + S_i (N_z + m + 1) $$
El espacio necesario sería menor que en COO, si $m + 1 < N_z$.

\begin{ejemplo} En la misma matriz:

$$ \textbf{A} = \mat{
	1 & 0 & 0 & 2 & 0 \\
	3 & 4 & 0 & 5 & 0 \\
	9 & 0 & \textbf{8} & 0 & 0 \\
	0 & 0 & 6 & 5 & 0 \\
	0 & 0 & 0 & 0 & 4 }
\quad
\begin{aligned}
	AA = \arr{ 1 & 2 & 3 & 4 & 5  & 9 & \textbf{8} & 6 & 5 & 4} \\
	JA = \arr{ 1 & 4 & 1 & 2 & 4  & 1 & \textbf{3} & 3 & 4 & 5}\\
	IA = \arr{ 1 & 3 & \textbf{6} & 8 & 10 & 11}
\end{aligned}
$$

Para acceder al elemento (3, 3), primero se calcula la posición en AA del 
elemento que comienza la tercera fila, este índice es IA[3] = 6. La tercera fila 
se sitúa en AA desde IA[3] = 6 hasta IA$[3+1]-1$ = 7.  Para determinar la 
columna se recorren los índices de JA desde 6 hasta 7, buscando la columna 3, 
que se encuentra en JA[7] = 3. De modo que el elemento buscado se encuentra en 
AA[7] = 8.

\end{ejemplo}

\subsection{Construcción de la puerta de Simon $U_s$}

Partiendo de una función $f$ conocida, con un período $s$, el conjunto de 
vectores $Y$ que satisface $y_i \oplus s = 0$
$$Y = \{ y_1, y_2 \ldots y_n \}$$
La puerta de Simon denominada $U_s$, es un operador que aplicado sobre un estado 
$\ket{x}\ket{y}$ lo transforma en $\ket{x}\ket{f(x) \oplus y}$
\begin{equation}
\label{Us_def} U_s\ket{x} \ket{y} = \ket{x} \ket{f(x) \oplus y}
\end{equation}
%
% XXX: No caer en la tentación de divulgar contenido carente de comprobación
% rigurosa. Comprobar siempre los pasos realizados.
%
% BEGIN contenido incorrecto
%

%Para construir dicho operador, será necesario una matriz de 
%$2^{2n}\times2^{2n}$. Dado que $Us$ no realiza ninguna operación sobre 
%$\ket{x}$, es posible dividirla en dos partes. La puerta identidad, que no 
%realiza cambios, y otra operación en el resto.
%$$ U_s = I^{\otimes n} \otimes F_s $$
%De este modo,
%$$
%	(I^{\otimes n} \otimes F_s)\ket{x} \otimes \ket{y} =
%	I^{\otimes n} \ket{x} \otimes F_s\ket{y} =
%	\ket{x} \otimes F_s\ket{y}
%$$
%Y partiendo de \ref{Us_def}, se obtiene:
%$$
%	\ket{x} \otimes F_s\ket{y} = \ket{x} \otimes \ket{f(x) \oplus y}
%	%Comprobar esto!
%$$

%
% END contenido incorrecto
%

$$
\begin{aligned}
	\ket{a} = \ket{x}\otimes\ket{y},& \quad a_H = x, \quad a_L = y \\
\end{aligned}
$$
$$ b_H = a_H, \quad b_L = f(a_H) \oplus a_L $$
Si $a,b \in \{0,1\}^{2n}, a = a_{2n-1} \ldots a_1, a_0 $, $a_L = a_{n-1} \ldots 
a_0$ y $a_H = a_{2n-1} \ldots a_n$.
De modo que, $U_s\ket{a} = \ket{b}$, adicionalmente:
$$
	U_s[b, a] = 1
$$

\begin{ejemplo}
Sea $f$ la función con período $s=01$, definida fomo sigue:
\begin{tabular}{|c|c|}
	\hline
	$x$ & $f(x)$ \\\hline
	00 & 00 \\
	01 & 00 \\
	10 & 01 \\
	11 & 01 \\\hline
\end{tabular}

Para calcular $U_s$:

\begin{tabular}{|c|cccc|cccc|cccc|cccc|}
	\hline
	$a$     &0&1&2&3& 4&5&6&7& 8&9&A&B &C&D&E&F \\
	$a_H$   &0&0&0&0& 1&1&1&1& 2&2&2&2 &3&3&3&3 \\
	$a_L$   &0&1&2&3& 0&1&2&3& 0&1&2&3 &0&1&2&3 \\
	$f(a_H)$&0&0&0&0& 0&0&0&0& 1&1&1&1 &1&1&1&1 \\
	$b_H$   &0&0&0&0& 1&1&1&1& 2&2&2&2 &3&3&3&3 \\
	$b_L$   &0&1&2&3& 0&1&2&3& 1&0&3&2 &1&0&3&2 \\
	$b$     &0&1&2&3& 4&5&6&7& 9&8&B&A &D&C&F&A \\
	\hline
\end{tabular}

De modo que:

\begin{tabular}{|c|cccc|cccc|cccc|cccc|}
	\hline
	$a$     &0&1&2&3& 4&5&6&7& 8&9&A&B &C&D&E&F \\
	$b$     &0&1&2&3& 4&5&6&7& 9&8&B&A &D&C&F&A \\
	\hline
\end{tabular}

El operador $U_s$ es reversible.
Si $U_s[b,a] = 1$, tambien $U_s[a,b] = 1$



\end{ejemplo}





\end{document}


\end
